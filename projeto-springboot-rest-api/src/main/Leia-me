
application.properties
As propriedades de configuração do Spring Boot relacionadas à conexão com o banco de dados e à configuração do Hibernate 
(ORM - Object-Relational Mapping). Vamos explicar cada uma delas em detalhes:

1. `spring.datasource.url`: Define a URL de conexão com o banco de dados. No exemplo dado, está configurado para uma conexão com o 
PostgreSQL em "localhost" na porta 5433 e com o banco de dados "springboot-rest-api".

2. `spring.datasource.username`: Define o nome de usuário do banco de dados para autenticação.

3. `spring.datasource.password`: Define a senha do usuário do banco de dados para autenticação.

4. `spring.jpa.hibernate.ddl-auto`: Define a estratégia de criação/validação das tabelas do banco de dados pelo Hibernate. No exemplo, 
está configurado como "update", o que significa que o Hibernate irá criar automaticamente as tabelas se elas ainda não existirem no banco 
de dados, mas se as tabelas já existirem, ele apenas irá atualizar a estrutura do esquema (não apagará os dados existentes).

5. `spring.datasource.driver-class-name`: Define a classe do driver do banco de dados que será usado para fazer a conexão. No exemplo, está 
configurado para o driver do PostgreSQL.

6. `spring.datasource.platform`: Define a plataforma do banco de dados que está sendo utilizada. No exemplo, está configurado como "postgres".

7. `spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults`: Essa propriedade é usada para otimizar a detecção de tipos de colunas 
do banco de dados pelo Hibernate. No exemplo, está configurado como "false" para que o Hibernate não utilize as configurações padrão do 
JDBC para metadados de colunas.

8. `spring.jpa.database-platform`: Define a classe do dialeto do banco de dados que será usada pelo Hibernate. No exemplo, está configurado 
para o dialeto do PostgreSQL.

9. `spring.jpa.properties.hibernate.dialect`: Define o dialeto do banco de dados que será usado pelo Hibernate. No exemplo, está configurado 
para o dialeto do PostgreSQL.

10. `server.servlet.context-path`: É uma configuração usada em aplicativos Spring Boot para especificar o caminho de contexto da servlet 
raiz para o aplicativo. O que isso significa é que, quando o aplicativo Spring Boot é iniciado, todas as solicitações HTTP para o 
aplicativo devem começar com o caminho de contexto /projeto-springboot-rest-api. Por exemplo, se o aplicativo estiver sendo executado em 
http://localhost:8080, uma solicitação para http://localhost:8080/projeto-springboot-rest-api/alguma-rota será roteada para o aplicativo 
correto.

Essas propriedades são essenciais para configurar corretamente a conexão com o banco de dados e o comportamento do Hibernate ao trabalhar 
com o banco de dados. Cada propriedade tem um papel importante na configuração da aplicação Spring Boot que utiliza o banco de dados 
PostgreSQL.

------------------------------------------------------------------- // --------------------------------------------------------------------

A interface JpaRepository faz parte do Spring Data JPA, que é um módulo do Spring Framework destinado a facilitar a integração com o JPA 
(Java Persistence API) para acesso a bancos de dados relacionais.

A JpaRepository é uma subinterface da PagingAndSortingRepository e define um conjunto de métodos padrão que fornecem operações CRUD 
(Create, Read, Update e Delete) básicas para entidades JPA, como salvar, atualizar, excluir e consultar registros em um banco de dados.

Aqui estão alguns dos métodos mais comuns fornecidos pela JpaRepository:

 -> save(T entity): Salva ou atualiza a entidade no banco de dados. Se a entidade já existe no banco, ela será atualizada, caso contrário, será inserida.

 -> deleteById(ID id): Exclui a entidade pelo ID especificado.

 -> findById(ID id): Busca a entidade pelo ID especificado.

 -> findAll(): Busca todas as entidades do tipo especificado.

 -> findAll(Pageable pageable): Busca todas as entidades com suporte para paginação e ordenação.

 -> count(): Retorna o número total de registros da entidade no banco de dados.

A vantagem de usar a JpaRepository é que você pode criar facilmente um repositório para suas entidades sem a necessidade de escrever as 
consultas SQL manualmente. Além disso, o Spring Data JPA fornece suporte para consultas personalizadas, permitindo que você defina métodos 
de consulta na interface do repositório e o Spring gerará automaticamente as consultas correspondentes com base nos nomes dos métodos.

Em resumo, a JpaRepository é uma interface poderosa do Spring Data JPA que simplifica a interação com o banco de dados e reduz a quantidade 
de código boilerplate necessário para criar um repositório de entidades JPA.

------------------------------------------------------------------- // --------------------------------------------------------------------

A anotação @Autowired é uma anotação do Spring Framework utilizada para realizar a injeção de dependências automaticamente em classes 
gerenciadas pelo contêiner de IoC (Inversion of Control) do Spring.

Quando você anota um campo, método setter ou construtor com @Autowired, o Spring irá procurar por uma instância do tipo da classe desse 
campo/método no contexto do contêiner e irá injetá-la automaticamente, sem que você precise criar a instância manualmente.

Existem várias maneiras de usar a anotação @Autowired:

1. Injeção em campo:

```
@Autowired
private ExemploService exemploService;
```

Neste caso, o Spring procurará uma instância de ExemploService no contexto do contêiner e a injetará no campo exemploService.

2. Injeção em método setter:

```
private ExemploService exemploService;

@Autowired
public void setExemploService(ExemploService exemploService) {
    this.exemploService = exemploService;
}
```
Nesse caso, o Spring procurará uma instância de ExemploService no contexto do contêiner e a injetará chamando o método setExemploService.

3. Injeção em construtor:
 ```
 private ExemploService exemploService;

@Autowired
public ClasseExemplo(ExemploService exemploService) {
    this.exemploService = exemploService;
}
 ```
Aqui, o Spring procurará uma instância de ExemploService no contexto do contêiner e a injetará automaticamente ao criar uma instância de 
ClasseExemplo.

É importante ressaltar que, para que a injeção de dependências funcione corretamente, a classe a ser injetada (no exemplo acima, a classe 
ExemploService) também deve ser um componente gerenciado pelo Spring, o que é geralmente feito por meio das anotações @Service, @Repository, 
ou @Component, dependendo do papel da classe na aplicação.

Além disso, é necessário configurar o Spring para fazer a varredura dos componentes e criar o contexto do contêiner, o que é geralmente 
feito com a anotação @SpringBootApplication ou outras anotações equivalentes, dependendo da versão do Spring que você está usando.

Em resumo, a anotação @Autowired é uma das principais ferramentas do Spring para realizar a injeção de dependências automaticamente e 
facilitar a configuração e gerenciamento de componentes em uma aplicação Spring.

------------------------------------------------------------------- // --------------------------------------------------------------------

A classe ResponseEntity é uma classe do Spring Framework que representa uma resposta HTTP personalizada que pode ser retornada por um 
controlador em uma aplicação web. Essa classe encapsula todos os detalhes da resposta HTTP, como corpo, cabeçalhos e status, permitindo que você defina esses detalhes de forma mais flexível.

Aqui estão os principais aspectos da classe ResponseEntity:

Tipo de Dados Genérico: ResponseEntity é uma classe genérica que permite especificar o tipo de dado que será retornado no corpo da 
resposta. Por exemplo, ResponseEntity<String> representa uma resposta que contém um corpo de texto (String), enquanto 
ResponseEntity<List<Usuario>> representa uma resposta que contém uma lista de objetos do tipo Usuario.

Corpo da Resposta: O corpo da resposta é o conteúdo que será enviado de volta ao cliente em uma resposta HTTP. Você pode definir o corpo 
da resposta passando o objeto apropriado para o construtor de ResponseEntity.

Cabeçalhos: A classe ResponseEntity permite que você defina os cabeçalhos da resposta, como "Content-Type", "Location", "Set-Cookie" e 
outros cabeçalhos personalizados.

Status HTTP: Você pode definir o status da resposta HTTP, como "200 OK", "201 Created", "404 Not Found", "500 Internal Server Error" etc., 
usando a enumeração HttpStatus. O status padrão é "200 OK" se não for especificado.

Outros Detalhes da Resposta: Além do corpo, cabeçalhos e status, a classe ResponseEntity também permite configurar outros detalhes da 
resposta, como a definição de cookies, redirecionamento e cache.

Flexibilidade: O uso da classe ResponseEntity oferece maior flexibilidade ao criar controladores em uma aplicação web, pois você pode 
personalizar todos os aspectos da resposta HTTP de acordo com suas necessidades.

Usar ResponseEntity<List<Usuario>> em um controlador permite que você retorne uma resposta HTTP personalizada contendo uma lista de 
objetos Usuario, juntamente com os cabeçalhos e o status apropriados. Essa classe oferece maior flexibilidade para personalizar a resposta 
de acordo com suas necessidades específicas.

A classe ResponseEntity<List<Usuario>> permite que você retorne a lista de usuários com um status apropriado, como "404 Not Found" se não 
houver usuários encontrados, ou qualquer outro status relevante para a resposta.

------------------------------------------------------------------- // --------------------------------------------------------------------

No Postman no end-point 'post' na aba raw e dentro do body vamos adicionar a codificação json:
   
{
        "id": "",
        "nome": "João",
        "idade": 24
}

------------------------------------------------------------------- // --------------------------------------------------------------------

Vale ressaltar que para deletar não vamos passar uma requisição e sim um parametro que vai ser passado o id do usuário que queremos deletar.
No postman para deletar não é passado por parametro o id na uri. Para deletar usando o id é passado pelo corpo (body) da requisição. E 
como faz isso, usando o postman?

Na aba "Body" é possível fazer pela opção 'x-www-form-urlenconded' ou o 'form-data', onde vai ser passado a key (userid) value (<valor do id>).

Para pesquisar (ou buscar) um usuário por id pelo postman é seguido o mesmo processo do deletar por id.

------------------------------------------------------------------- // --------------------------------------------------------------------

No postman no end-point 'put' na aba raw e dentro do body vamos adicionar a codificação json para atualizar.

{
        "id": 2,
        "nome": "Marcelo",
        "idade": 39
}

------------------------------------------------------------------- // --------------------------------------------------------------------

Criando a página inicial com Bootstrap

Site: https://getbootstrap.com/docs/4.0/getting-started/introduction/
Include via CDN: https://getbootstrap.com/

------------------------------------------------------------------- // --------------------------------------------------------------------
Instalando JQuery no projeto

Basta copiar o script.
minified: https://releases.jquery.com/

OBS. No caso já temos o jQuery que foi pego no momento que add o cdn do bootstrap.

------------------------------------------------------------------- // --------------------------------------------------------------------
Botão de novo - fazer um reset

Em jquery
https://www.geeksforgeeks.org/how-to-reset-a-form-using-jquery-with-reset-method/

Em javascript
https://www.w3schools.com/jsref/met_form_reset.asp
